---
layout: post
title: Introduction to x86_64 linux assembly part 3 (nasm) (GNU/linux)
---

## Introduction
From our last blog, I have explain on how to write your very own basic hello world program in assembly! I will now explain how to disassemble a basic hello world C program so you can read and learn assembly code from C to see how it actually works behind the scenes!

Typing in the terminal `man objdump` shows the following:
> objdump - display information from object files

And this is the definition from [Wikipedia](https://en.wikipedia.org/wiki/Objdump)
> objdump is a command-line program for displaying various information about object files on Unix-like operating systems. For instance, it can be used as a disassembler to view an executable in assembly form.

As you can see from the above definition, `objdump` is a simple CLI GNU utility for viewing information related to intermediate object files / executable files! 

There are a few command line options we will be using: `-d` for disassemble, and `-M` for disassembler options!

For instance, disassembling an obj file called `main.o` generated by a compiler would look as follow:
```
objdump -D main.o
```

This will output mostly the `.text` and `.data` sections we talked about from the previous blog, and many more! For now, we should focus on instead the lower case version of the disassembling option `-d` instead.

## Disassembling the object file for a C program
Create the following C program with the code from below:
```c
#include <stdio.h>

int main(void) {
    printf("Hello world!\n");
    return 0;
}
```

And save it as "main.c"

Normally, if we compile it using `gcc` the command it should look like this:
```sh
gcc main.c -o main
```

which also runs the linker, then proceeds to outputs an executable with the file name called "main".

But what if we don't want the linker to link for us yet? We can use the `-c` option in `gcc` for this:
```sh
gcc main.c -c
```

The `-c` options simply tells gcc to not link, but only generate an object file from the given source code.


If you did everything right, you should probably have a file called: "main.o" in your directory. That is the object file generated by our simple hello world C program! Now let's dissect it using `objdump`! Type the following command:
```sh
objdump -d main.o
```

This command disassembles the object file, and you should be prompted with the following output:
```sh
main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # b <main+0xb>
   b:   48 89 c7                mov    %rax,%rdi
   e:   e8 00 00 00 00          call   13 <main+0x13>
  13:   b8 00 00 00 00          mov    $0x0,%eax
  18:   5d                      pop    %rbp
  19:   c3                      ret
```

Now, you can see there is a lot going on here! What are those numbers on the left? And why is the instructions on the right different from our normal rsp rbp? Why is there a `%` sign?


Don't panic! We will go through this one by one, for now, let's convert the assembly into the intel flavored instruction! The `%` sign is actually just from a different design, from a different set of assembly instructions! But the overall concept should be the same. To convert the assembly code, we should use the `-M`  option for `objdump`, this will tell `objdump` to instead "emit" intel flavored code instead.

```sh
objdump -M intel -d main.o
```

You should have the following output:
```sh
main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   48 8d 05 00 00 00 00    lea    rax,[rip+0x0]        # b <main+0xb>
   b:   48 89 c7                mov    rdi,rax
   e:   e8 00 00 00 00          call   13 <main+0x13>
  13:   b8 00 00 00 00          mov    eax,0x0
  18:   5d                      pop    rbp
  19:   c3                      ret
```

Now this is more familiar! Let's now try to go through this one by one.
At the top we have the file description, the file is called "main.o", and the file format is given as `elf64-x86-64`. Which simply means it's a 64bit ELF file that is compiled for the x86_64 architecture!


Next up we can see the `.text` section, it shows us a function called `<main>` situated at location 0 (you can see the zeroes in front of our main label `0000000000000000 <main>:`, that represents the address this label is situated. For now, we only have one function, therefore there's only one label.


Next up, the assembly code, the number to the left with a colon at the end represents the starting location of the current instruction, and after the colon, the hexadecimals represent the raw hex bytes of the instruction given on the right! Do note that two hexadecimal digits are considered one byte! This is the reason why the hexadecimals are split in space by two digits. This makes it so that the raw bytes are easier to read and organized in bytes!
```sh
   0:   55 
   1:   48 89 e5
   4:   48 8d 05 00 00 00 00
   b:   48 89 c7
   e:   e8 00 00 00 00
  13:   b8 00 00 00 00
  18:   5d
  19:   c3
```

Here, `55` means the entire instruction `push rbp`, and `48 89 e5` represents the entire instruction `mov rbp, rsp` etc. Pretty cool right!


Let's now understand the assembly code given here. I have removed certain parts of the assembly so we can focus on the actual contents. I will explain the other parts later. I also removed the raw bytes and addresses for better clarity.
```sh
  ...
  lea    rax,[rip+0x0]        # b <main+0xb>
  mov    rdi,rax
  call   13 <main+0x13>
  mov    eax,0x0
  ...
  ret
```


First, recall from our last blog that `lea` will resolve the value on the right and read it as a pointer. But as you can see, we are doing an arithmetic operation here `[rip + 0x0]` means to first offset the value given within the `rip` register, which is actually called the 64bit instruction pointer. Then we proceed to load the address at that location into `rax`.

```nasm
lea rax, [rip + 0x0]
```


Next, we load the value `rax` into `rdi`, which is the address pointed at `rip + 0x0`.
```nasm
mov rdi, rax
```


Now, as you can observe, the next is a `call` instruction, this instruction will call a function given a label or an address. The reason we see the value 13 is that the disassembled code is actually not `linked` yet. The linker will actually handle what is actually replaced here in `13`. Since we only disassembled the object file, it's obvious the linker didn't had the chance to link these functions to what they are supposed to be running, hence the dummy value 13.

```
call 13 <main+0x13>
```

`mov` will load the value `0x0`(which is 0 in decimal) into the 32bit register `eax`
Then finally we call `ret` to return out of the main function! Which utilizes `eax` as it's return value. Hence our exit status should be 0.

## Disassembling the executable for a C program

Now, as I have said in the previous section, an object file is an intermediate file that contains "incomplete" code that requires linking to get the final executable. That's why there's dummy variables and values within the object file especially if the function / procedure called is from an external library. In our case, we are using the `stdio.h` standard I/O library from the C standard library. Therefore the linker actually links the libc library for us after compilation!


Let us compile our `main.c` and try to disassemble it:
```sh
gcc main.c -o main
objdump -M intel -d main
```

`objdump` should be able to dump information not only for object files, but for ELF executables as well! If you run the given command, you should see a bunch of output. Worry not, if you continuously scroll down, you should see the text `Disassembly of section .text:`, That is the actual assembly code section we care about.

Inside the `.text` section, you should see the following two functions `_start` and `main`:
```
0000000000001040 <_start>:
	code for _start
	
0000000000001139 <main>:
	code for main
```

The `_start` function is actually the entry code generated by the C compiler, this function will initialize things related to the stack, heap and more. It also initializes the C standard library. Explaining this part is out of the scope of our blog. So let us just focus on the `main` function for now.


```sh
0000000000001139 <main>:
    1139:	55                   	push   rbp
    113a:	48 89 e5             	mov    rbp,rsp
    113d:	48 8d 05 c0 0e 00 00 	lea    rax,[rip+0xec0]        # 2004 <_IO_stdin_used+0x4>
    1144:	48 89 c7             	mov    rdi,rax
    1147:	e8 e4 fe ff ff       	call   1030 <puts@plt>
    114c:	b8 00 00 00 00       	mov    eax,0x0
    1151:	5d                   	pop    rbp
    1152:	c3                   	ret
```

Now you can see, most of the code is the same, but we do have two differences, mainly:
1.  third line `lea rax, [rip+0x0]` --> `lea rax,[rip + 0xec0]`
2.  fifth line `call 13 <main + 0x13>` --> `call 1030 <puts@plt>`


Without going into the details, the linker has now resolved most of the "missing parts" of our previous object file, it now contains the correct location of the string "Hello World!\n", and now calls the function correctly with a given address pointing to that function `1030`, which you can see calls the `puts` function. The `puts` function just simply prints out the content of the string out into stdout.

Yay, pretty cool right! That is one hell of a dive! Next, let's try calling an external C standard library function for ourselves in assembly~

## Interfacing C within nasm
Recall previously our code:
```asm
BITS 64
CPU X64

global _start

SECTION .text

_start:
    mov rax, 0x1
    mov rdi, 0x1
    lea rsi, [message]
    mov rdx, 13
    syscall

    mov rax, 60
    mov rdi, 0
    syscall

SECTION .data
message: db "Hello world!", 10
```

Which simply loads a bunch of characters, then print them out utilizing the `write` system call and finally exiting with an exit code of 0 using the `exit` system call.

Let us try using puts in our assembly as well! To let nasm know we are using an external symbol, we have to use the `extern` directive. At the top we add `extern puts`.

```nasm
BITS 64
CPU X64

extern puts

global _start

SECTION .text
	... omitted
```

Now, since we are going to use libc functions, we must then follow the C standard library procedures! Here we have to change our `_start` label into a label called `main` ain't that sound familiar?

After changing the entry point label name, it should now look like this:
```nasm
... omitted

SECTION .text

main:
    mov rax, 0x1
    mov rdi, 0x1
    lea rsi, [message]
    mov rdx, 13
    syscall

    mov rax, 60
    mov rdi, 0
    syscall

SECTION .data
message: db "Hello world!", 10
```

Our main function now should also call the `ret` instruction instead of manually calling `exit` system call! Remember `rax` register is considered instead by the `ret` instruction as the exit code!

```
... omitted

main:
    mov rax, 0x1
    mov rdi, 0x1
    lea rsi, [message]
    mov rdx, 13
    syscall

	mov rax, 0x0
	ret

... omitted
```

Now we should replace our `write` call with our puts function, but before we start, we have to know how does this function work? Well, the function signature is `int puts(const char* s)`. It simply takes in 1 argument as the output, and returns how many characters has been put out.


In x86_64 linux, the C call convention for functions are simple, it still follows the linux syscall call convention, where first argument goes to `rdi`, second goes to `rsi` etc. There is one exception though, when there are too many arguments, then the extra arguments are then stored within the stack! For now, we will not be going into stack, that will be a blog for another day.


We have to first load the address of our "Hello world!" string into `rdi` register as it's considered by the call convention as the first argument then we call `puts`.


If you did everything, your assembly code should look like this.

```nasm
BITS 64
CPU X64

extern puts

global main

SECTION .text

main:
    lea rdi, [message]
    call puts

    mov rax, 0x0
    ret

SECTION .data
message: db "Hello world!", 10
```

Now, let us try to link the c library with the object file we have written, we can use the `-l` option. This option accepts a library name, here the library name is just `c`, hence `-lc`
```sh
nasm -f elf64 hello.asm
ld hello.o -lc -o hello
```

You will get an error similar to the following:
```
ld: warning: cannot find entry symbol _start; defaulting to 0000000000401020
```

As you can see, the linker expects the `_start` symbol to be defined, but we have explained before, libc should define `_start` no? Then why is it not working?


Well, it just so happens `-lc` actually links towards only the core code of libc, not the actual runnable code. When we compile using `gcc`, it actually does more than just linking towards libc, it also links towards setup code, initialization code, and finalization code. And all of those are in separate object files! (namely crt1.o, crti.o and crtn.o)


But hold on, do not worry, we can just tell `gcc` to link for us! Just think of it as a normal source file for `gcc` and it should link normally:
```sh
gcc hello.o -o hello
```


Uh oh, but it also isn't that easy! We got an error relating to relocation... This is quite a complex topic, so let's avoid this by linking the object file without PIE (position independent executable), we will discuss this topic in the next blog!

To get around this, we simply use the option: `-no-pie` to disable Position Independent Executable
```sh
gcc -no-pie hello.o -o hello
```

If you did everything correctly you should get an executable of the name "hello". Let's execute it.

```
./hello
```

Hopefully you will get the following output:
```
Hello World!
```

Congratulations! Though, we aren't fully complete, there is one thing missing. When we are using `puts` or string related functions from the standard library, it is required that we add a null terminator(\0) at the end to indicate the end of the bytes of string. Hence we change this line that defines the message from:
```
message: db "Hello world!", 10
```

Into:
```
message: db "Hello world!", 10, 0
```

Where we simply add a comma and a 0 at the end, indicating we are defining a new byte of value 0.

Compiling and running it should give you: "Hello world!". That's all for today! We have learnt how to disassemble a simple C program, and knew how to call C standard library functions within x86_64 assembly!


In our next blog, I will show you how to export your assembly code and run it in C (the other way around!), and we will learn how to do simple mathematical operations such as add, subtract, multiply and divide!


Until next time, Cheers!
